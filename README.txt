Установка Flask

        pip install Flask

Создаем рабочий файл site.py, импортируем Flask и пишем первое приложение. Просто переход на страницу

        from flask import Flask

        app = Flask(__name__)  # Создаем экземпляр класса Flask (приложение)

        @app.route('/')  # Декоратор, который связывает URL со функцией. По адресу '/' будет вызываться функция index
        def index():
            return 'Домашняя страница'  # Возвращает просто строку 'Домашняя страница'

        if __name__ == '__main__':
            app.run(debug=True)  # Запускаем приложение

Если хотим добавить еще новую страницу, то добавляем еще один роутер

        @app.route('/about')  # Декоратор, который связывает URL со функцией. По адресу '/about' будет вызываться функция about
        def about():
            return '<h1>О нас</h1>'  # Возвращает просто заголовок 'О нас'

Если один и тот же обработчик (функция) должн срабатывать по нескольким адресам, то роутеры можно просто расположить друг над другом

        @app.route('/index')  # Декоратор, который связывает URL со функцией. По адресу '/index' будет вызываться функция index  
        @app.route('/')  # Декоратор, который связывает URL со функцией. По адресу '/' будет вызываться функция index
        def index():
            return 'Домашняя страница'  # Возвращает просто строку 'Домашняя страница'

******************************************************************************************************************************************
******************************************************************************************************************************************
******************************************************************************************************************************************
2. Шаблонизаторы

Чтобы воспользоваться шаблонами необходимо дополнительно импортировать модуль из Flask

        from flask import Flask, render_template

И тогда вызываем именно отдельно хранящийся шаблон.
Шаблоны берутся из подкаталога templates относитьльно нашей рабочей программы.
Создадим templstes/index.html в папке с site.py

        @app.route('/')  # Декоратор, который связывает URL со функцией. По адресу '/' будет вызываться функция index
        def index():
            return render_template('index.html')  # Возвращает HTML-шаблон с именем 'index.html'

Делаем тоже самое для второй страницы about

        @app.route('/about')  # Декоратор, который связывает URL со функцией. По адресу '/about' будет вызываться функция about
        def about():
            return render_templates('about.html')  # Возвращает HTML-шаблон с именем 'about.html'

Параметры передаются в шаблоны с помощию {{ }}
Установим для title и заголовка h1 в обоих шаблонах

        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title> {{ title }} </title>
        </head>
        <body>
            <h1> {{ title }} </h1>
        </body>
        </html>

И при передаче шаблона установим значение параметра title

        @app.route('/')  # Декоратор, который связывает URL со функцией. По адресу '/' будет вызываться функция index
        def index():
            return render_template('index.html', title='Главная страница')  # Возвращает HTML-шаблон с именем 'index.html' и переменной title в параметрах


        @app.route('/about')  # Декоратор, который связывает URL со функцией. По адресу '/about' будет вызываться функция about
        def about():
            return render_template('about.html', title='О нас')  # Возвращает HTML-шаблон с именем 'about.html' и переменной title в параметрах

Передадим список в шаблон. Выражения в шаблонах помещаются в {% %}. В конце обязательно закрытие выражения {% end... %}

        </head>
        <body>
            <ul>
                {% for m in menu %}
                <li>{{m}}</li>
                {% endfor %}
            </ul>
            <h1> {{ title }} </h1>
        </body>
        </html>

В коде пропишем этот список menu и укажем его так же при передаче шаблона. Укажем новый параметр menu и передадим в него наш список

        menu = ['Главная', 'О нас', 'Контакты']

        @app.route('/')  # Декоратор, который связывает URL со функцией. По адресу '/' будет вызываться функция index
        def index():
            return render_template('index.html', title='Главная страница', menu=menu)

Немного усложним. Добавим условие if. Если передаем параметр title в обработчик - получаем Первый сайт - {{ title }}.
Если title не передается, то просто пишется заранее подготовленный текст "Первый сайт"

        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            {% if title %}
                <title>Первый сайт - {{ title }}</title>
            {% else %}
                <title>Первый сайт</title>
            {% endif %}
        </head>

Примерно тоже самое сделаем для body

        <body>
            <ul>
                {% for m in menu %}
                <li>{{m}}</li>
                {% endfor %}
            </ul>
            {% if title %}
                <h1>{{ title }}</h1>
            {% else %}
                <h1>Первый сайт - Главная страница</h1>
            {% endif %}    
        </body>

Тоже самое делаем для about

Делаем БАЗОВЫЙ шаблон base.html. Он содержит основную информацию, для предотвращения повторений ее в коде других страниц 
Все разбивается на блоки, которые потом будут заполняться или останутся с тем что задано, если этот блок не указан в определенном шаблоне

        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            {% block title %}
            {% if title %}
                <title>Первый сайт - {{ title }}</title>
            {% else %}
                <title>Первый сайт</title>
            {% endif %}
            {% endblock title %}
        </head>
        <body>
            {% block content %}
            {% block mainmenu %}
            <ul>        
                {% for m in menu %}
                <li>{{m}}</li>
                {% endfor %}
            </ul>
            {% endblock mainmenu %}
            {% if title %}
                <h1>{{ title }}</h1>
            {% else %}
                <h1>Первый сайт - Главная страница</h1>
            {% endif %}   
            {% endblock content %} 
        </body>
        </html>

Перепишем шаблон index. Благодаря super() отображает то что было в базовом шаблоне, а не просто заменяет содержимым блока content

        {% extends "base.html" %}

        {% block content %}
        {{ super() }}
        <p>Cодержимое главной страницы</p>
        {% endblock content %}

Перепишем шаблон about

        {% extends "base.html" %}

        {% block content %}
        {{ super() }}
        <p>Cодержимое страницы о нас</p>
        {% endblock content %}


******************************************************************************************************************************************
******************************************************************************************************************************************
******************************************************************************************************************************************
3+4. Контекст приложения и контекст запроса + функция url_for
   
ЗАПРОС ОТ ПОЛЬЗОВАТЕЛЯ = КОНТЕКСТ ПРИЛОЖЕНИЯ (g, current_app) + КОНТЕКСТ ЗАПРОСА (request, session)

Контекст приложения (создаается в первую очередь, до контекста запроса, но его наличие не обязательно):
g - пользовательская информация (например текущее соединение с базой данных). Как только обработка запрооса завершается данные удаляются.
current_app - ссылается на контекст текущего приложения, активизированного для соответствующего запроса

Контекст запроса (обязателен):
request - содержит данные запроса, включая url. Часто это данные get запроса (или post запроса при загрузке файлов). Эта переменная доступна
    в пределах потока данного запроса. 
session - словарь, в котором можно сохранять данные в пределах сессии. Т.е. она не удаляется после обработки запроса. И если запрос повторится,
    то данные будут браться из него (например данные авторизации пользователя, которые хранятся какой то период времени)


Функция url_for - позволяет генерировать url адрес по имени функции обработчика.
По факту возвращает то, что написано в @app.route
НАПРИМЕР

        from flask import url_for

        app = Flask(__name__)

        menu = ['Главная', 'О нас', 'Контакты']

        @app.route('/')
        def index():
            print(url_for('index'))
            return render_template('index.html', title='Главная страница', menu=menu)

Здесь импортированная и вызванная в print функция url_for будет выводить в консоль '/' при каждом обращении к адресу главной страницы. 

Она нужна для относительного указания url адреса, чтобы не прописывать его вручную. Ведь если он изменится, то придется менять вручную
во всех местах кода, где этот адрес используется.
Или когда url генерируется динамически и мы физически не можем его прописать вручную заранее.
Если с обработчиком связано несколько url адресов, то будет указан только тот, который находится ближе к самому обработчику.
Эта функция работает только в контексте запроса и работает с этим запросом. Если вызвать ее вне обработчика, то будет ошибка.

Можно создать ТЕСТОВЫЙ КОНТЕКСТ ЗАПРОСА не запуская веб сервер
Закоментируем строки:

        if __name__ == '__main__':
            app.run(debug=True)  # Запускаем приложение

И пропишем:

        with app.test_request_context():
            print(url_for('index'))

Это позволит протестировать функцию url_for для любого обработчика вне его.

СПОСОБЫ ОПИСАНИЯ URL

Мы привязывали адреса с помощью декоратора route.
Но можно привязывать их к переменным и получить динамические адреса

        @app.route('/url/<переменная>)

Т.е. переменная будет принимать значение, определяемое соответствующим url адресом

        @app.route('/profile/<username>')  # Декоратор, который связывает URL со функцией. По адресу '/profile/<username>' будет вызываться функция profile
        def profile(username):
            return f'Профиль пользователя {username}'

При запуске сервера и переходе по адресу http://127.0.0.1:5000/profile/phk мы получим вывод "Профиль пользователя phk".
Т.е. в переменную username поместилось то, что мы прописали в url адресе. 
Это работает только для переменной которая написана после слеша.
Если написать http://127.0.0.1:5000/profile/phk/phk то получим ошибку, т.к. тут уже другая структура.

Для исправления используется path

        @app.route('/profile/<path:username>')  # Декоратор, который связывает URL со функцией. По адресу '/profile/<username>' будет вызываться функция profile
        def profile(username):
            return f'Профиль пользователя {username}'

Теперь переменная username будет приниимать вообще весь оставшийся путь прописанный после profile/ 

КОНВЕКТОРЫ:
int - должны присутствовать только цифры
float - можно записывать число с плавающей точкой
path - можно использовать любые допустимые символы url плюс символ /

Можно совмещать конвекторы

        @app.route('/profile/<int:username>/<path>')  
        def profile(username, path):
            return f'Профиль пользователя {username}, {path}'

Будет ждать от нас http://127.0.0.1:5000/profile/123/phk с ответом Профиль пользователя 123, phk

******************************************************************************************************************************************
******************************************************************************************************************************************
******************************************************************************************************************************************
5. Подключение внешних ресурсов и работа с формами

Через url_for можно так же подключать внешние файлы. Например CSS и JS

        url_for('static', filename='css/style.css')

Указываем каталог static и укзываем какой именно файл из этого каталога взять.
Каталог static должен быть на том же уровне вложенности, что и каталог templates.

Создадим static/css/style.css и добавим стили в наш base.html

        <!DOCTYPE html>
        <html lang="en">
        <head>
            <link type="text/css" rel="stylesheet" href="{{ url_for('static', filename='css/style.css')}}">
            <meta charset="UTF-8">

И несколько тегов div

            {% endblock mainmenu %}
            <div class='clear'></div>
            <div class="content">
                {% if title %}
                    <h1>{{ title }}</h1>
                {% else %}
                    <h1>Первый сайт - Главная страница</h1>
                {% endif %}   
                {% endblock content %} 
            </div>
        </body>

АКТИВИРУЕМ МЕНЮ

Вместо списка делаем список словарей.
            menu = [{'name': 'Установка', 'url': 'install-flask'},
                    {'name': 'Первое приложение', 'url': 'first-app'},
                    {'name': 'Обратная связь', 'url': 'contact'}]

И в базовом шаблоне сделаем ссылки

            <ul class='mainmenu'>        
                {% for m in menu %}
                <li><a href='{{m.url}}'>{{m.name}}</a></li>
                {% endfor %}
            </ul>


ФОРМЫ

Формы в html прописываются следующим образом:

            <form action='/handler' method='POST'>
            ....
            <input type='submit' value='Отправить'>
            </form>

'/handler' - url который принимает данные от Формы
'POST' - метод (отправка)
'submit' - отправляет данные формы на сервер

Добавим на страницу форму обратной связи в файле contact.html
    
            {% extends 'base.html' %}

            {% block content %}
            {{super()}}
            <form action='/contact' method='post' class='form-contact'>
                <p><label>Имя: </label> <input type="text" name='username' value='' requied>
                <p><label>Email: </label><input type="text" name='email' value='' requied>
                <p><label>Сообщение: </label>
                <p><textarea name="message" rows=7 cols=40></textarea>
                <p><input type="submit" value='Отправить'>
            </form>
            {% endblock content %}

Добавляем обработчик для страницы contact

            @app.route('/contact')
            def contact():
                return render_template('contact.html', title='Обратная связь', menu=menu)

При отправке будет ошибка, т.к. для метода  POST обработчику необходимо это прямо указать.
А так же проверим что передается именно метод post. И поймаем через print что именно передается.

            from flask import Flask request

            @app.route('/contact', methods=['POST', 'GET'])
            def contact():
                if request.method == 'POST':
                    print(request.form)  # Печатаем данные формы
                    print(request.form['username'])  # Печатаем значение поля username

                return render_template('contact.html', title='Обратная связь', menu=menu)

В атрибуте methods в списке указываются все разрешенные методы.
Через request можно обратиться к какому либо атрибуту в данном запросе.

******************************************************************************************************************************************
******************************************************************************************************************************************
******************************************************************************************************************************************
6. Мгновенные сообщения - flash, get_flashed_messages

Например при отправке данных появляется сообщение "Сообщение отправлено"
Реализуется во flask с помощью двух функций flash() и get_flashed_messages()

При отправке пользователем сообщения мы на сервере с помощью flash создаем сообщения.
А потом функцией get_flashed_messages отправляем их.

            flask.flash(message, category='message)
            flask.get_flashed_messages(with_categories=False, category_filter=[])

message - текст сообщения
category - категория сообщения
with_categories - разрешает использование категорий при извлечении сообщений
category_filter - список разрешенных категорий при выборке сообщений

Реализуем в форме обратной связи. Импортируем flash
Так же для работы с сессиями обязательно использовать секретный ключ.
Задаем его в начеле, там где объявляли класс Flask

            from flask import Flask flash

            app = Flask(__name__)  # Создаем экземпляр класса Flask (приложение)
            app.config['SECRET_KEY'] = '123456789'

            ...

            @app.route('/contact', methods=['POST', 'GET'])
            def contact(): 
            if request.method == 'POST':
                if len(request.form['username']) > 2:
                    flash('Сообщение отправлено', category='success')
                else:
                    flash('Ошибка отправки', category='error') 

            return render_template('contact.html', title='Обратная связь', menu=menu)

Категории для того чтобы потом в css разделить эти сообщения по визуалу

Далее в шаблоне будем вставлять get_flashed_messages. Циклом проходимся по категориям и сообщениям и выводим.
Если Flash не прописаны в обработчике, то это div просто не отобразится.

            {% extends 'base.html' %}

            {% block content %}
            {{super()}}
            {% for cat, msg in get_flashed_messages(True) %}
                <div class="flash {{cat}}">{{msg}}</div>
            {% endfor %}

            <form action='/contact' method='post' class='form-contact'>
                ........
            </form>
            {% endblock content %} 


















